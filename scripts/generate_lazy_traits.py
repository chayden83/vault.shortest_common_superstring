#!/usr/bin/env python3
"""
generate_lazy_traits.py

Generates C++ template specializations (traits) for the LazyFlatBuffers library.
This script bridges the gap between the runtime binary schema (.bfbs) and compile-time C++ logic.

Usage:
    python3 generate_lazy_traits.py <schema_bfbs> <output_hpp> <include_header>

Process:
    1. Loads the binary schema (.bfbs) generated by flatc.
    2. Inspects the schema for tables containing the 'nested_flatbuffer' attribute.
    3. Resolves the string type name (e.g., "Game.Monster") to its full C++ equivalent.
    4. Generates a C++ header file specializing 'lazyfb::traits::nested_type' for each valid field.
"""

import sys
import os
import argparse
from typing import List, Dict, Optional, Set

# -----------------------------------------------------------------------------
# Dependency Check
# -----------------------------------------------------------------------------
try:
    import flatbuffers
except ImportError:
    print("CRITICAL ERROR: The 'flatbuffers' python package is missing.")
    print("Please install it via: pip install flatbuffers")
    sys.exit(1)

# These modules are generated by CMake from reflection.fbs and injected into PYTHONPATH.
# If they are missing, it usually means the CMake build order is incorrect.
try:
    import reflection.Schema
    import reflection.Object
    import reflection.Field
    import reflection.BaseType
except ImportError:
    print("CRITICAL ERROR: Could not import 'reflection' modules.")
    print(f"Current PYTHONPATH: {sys.path}")
    print("Ensure your CMake configuration properly generates and links reflection.fbs.")
    sys.exit(1)


# -----------------------------------------------------------------------------
# Configuration & Constants
# -----------------------------------------------------------------------------

# The attribute name used in .fbs files to mark a field as a nested buffer.
NESTED_ATTRIBUTE_KEY = "nested_flatbuffer"

# C++ namespace where the traits should be generated.
TRAITS_NAMESPACE = "lazyfb::traits"

# C++ header file that defines the 'lazy_wrapper' and base traits.
LAZY_WRAPPER_HEADER = "vault/flatbuffers/flatbuffers.hpp"


# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

def get_namespace(obj_name: str) -> str:
    """
    Extracts the namespace portion of a fully qualified FlatBuffer name.
    Example: "Game.World.Zone" -> "Game.World"
    """
    if "." in obj_name:
        return ".".join(obj_name.split(".")[:-1])
    return ""

def to_cpp_type(flatbuffer_name: str) -> str:
    """
    Converts a FlatBuffer dot-notation name to a C++ scoped name.
    Example: "Game.World.Zone" -> "Game::World::Zone"
    """
    return flatbuffer_name.replace(".", "::")


# -----------------------------------------------------------------------------
# Core Logic Class
# -----------------------------------------------------------------------------

class SchemaAnalyzer:
    """
    Parses a binary FlatBuffers schema (.bfbs) and identifies fields that require
    lazy C++ traits.
    """

    def __init__(self, schema_bytes: bytes, filename: str):
        """
        Initialize the analyzer with the raw bytes of a .bfbs file.
        
        Args:
            schema_bytes: The raw content of the .bfbs file.
            filename: The name of the file (used for ownership filtering).
        """
        self.filename = filename
        
        # Verify schema identifier (standard FlatBuffers binary identifier)
        # Note: 'BFBS' is the file identifier for binary schemas.
        if len(schema_bytes) < 8:
            raise ValueError(f"File '{filename}' is too small to be a valid schema.")
            
        try:
            self.schema = reflection.Schema.Schema.GetRootAsSchema(schema_bytes, 0)
        except Exception as e:
            raise RuntimeError(f"Failed to parse schema root from '{filename}': {e}")

        # Index all objects (tables/structs) for fast lookup by name.
        self.objects_by_name: Dict[str, reflection.Object.Object] = {}
        self._index_objects()

    def _index_objects(self) -> None:
        """
        Iterates over all objects in the schema and builds a name-to-object map.
        This includes objects from included schemas if they were merged by flatc.
        """
        for i in range(self.schema.ObjectsLength()):
            obj = self.schema.Objects(i)
            name = obj.Name().decode("utf-8")
            self.objects_by_name[name] = obj

    def resolve_type_name(self, target_name: str, context_namespace: str) -> Optional[str]:
        """
        Resolves a potentially partial type name (from the attribute) to a fully
        qualified FlatBuffer type name existing in the schema.

        Resolution Strategy:
            1. Absolute Match: Check if 'target_name' exists exactly.
            2. Relative Match: Check if 'context_namespace.target_name' exists.
            3. Strict Suffix Match: Check if any type ends with '.target_name'.
               - Fails if multiple types match (ambiguity).
        
        Returns:
            The fully qualified name (e.g., "Game.Monster") or None if not found.
        """
        # 1. Absolute match
        if target_name in self.objects_by_name:
            return target_name
        
        # 2. Relative match (sibling in the same namespace)
        if context_namespace:
            relative_name = f"{context_namespace}.{target_name}"
            if relative_name in self.objects_by_name:
                return relative_name
        
        # 3. Strict suffix match (Global search)
        # We enforce a dot prefix to ensure we match full path components.
        # e.g. "Monster" matches "Game.Monster" but "onster" does not match "Monster".
        suffix_query = f".{target_name}"
        matches = [k for k in self.objects_by_name.keys() if k.endswith(suffix_query)]
        
        if len(matches) == 1:
            return matches[0]
        elif len(matches) > 1:
            print(f"ERROR: Ambiguous type reference '{target_name}' in '{self.filename}'.")
            print(f"       Found multiple candidates: {matches}")
            print(f"       Action: Please verify the 'nested_flatbuffer' attribute uses the fully qualified name.")
            sys.exit(1)
            
        return None

    def validate_field_compatibility(self, field: reflection.Field.Field, table_name: str) -> bool:
        """
        Validates that a field marked with 'nested_flatbuffer' is technically capable
        of holding a nested buffer. In FlatBuffers, this MUST be a vector of ubytes.
        
        Returns:
            True if valid, False (with a warning print) if invalid.
        """
        type_obj = field.Type()
        base_type = type_obj.BaseType()
        element_type = type_obj.Element()

        # Check: Must be [ubyte] or [byte]
        is_vector = (base_type == reflection.BaseType.BaseType.Vector)
        is_byte_vector = (element_type == reflection.BaseType.BaseType.UByte or 
                          element_type == reflection.BaseType.BaseType.Byte)
        
        if not (is_vector and is_byte_vector):
            field_name = field.Name().decode("utf-8")
            print(f"WARNING: Field '{table_name}::{field_name}' in '{self.filename}' matches a nested trait")
            print(f"         but has type '{base_type}'. Nested buffers must be '[ubyte]'. Skipping.")
            return False
        
        return True

    def extract_traits(self) -> List[str]:
        """
        Main pass: Iterates over all objects and fields to generate C++ trait definitions.
        
        Returns:
            A list of strings, where each string is a complete C++ struct specialization.
        """
        traits: List[str] = []
        
        # We strip the extension to match against the 'DeclarationFile' metadata.
        # e.g., "monster.bfbs" -> "monster.fbs"
        current_schema_base = os.path.basename(self.filename).replace(".bfbs", ".fbs")

        for i in range(self.schema.ObjectsLength()):
            obj = self.schema.Objects(i)
            
            # Structs cannot hold nested buffers (they are fixed size).
            if obj.IsStruct():
                continue

            # -------------------------------------------------------------------------
            # Ownership Check (Transitive Dependency Handling)
            # -------------------------------------------------------------------------
            # We only generate traits for tables defined in the CURRENT file.
            # If 'DeclarationFile' is present (it usually is with --reflect-names), we use it.
            if hasattr(obj, 'DeclarationFile') and obj.DeclarationFile():
                decl_file = obj.DeclarationFile().decode("utf-8")
                # If the declaration file doesn't match our current target, skip it.
                # This prevents 'world.fbs' from re-generating traits for 'monster.fbs'.
                if os.path.basename(decl_file) != current_schema_base:
                    continue

            full_table_name = obj.Name().decode("utf-8")
            cpp_table_name = to_cpp_type(full_table_name)
            namespace = get_namespace(full_table_name)

            for j in range(obj.FieldsLength()):
                field = obj.Fields(j)
                field_name = field.Name().decode("utf-8")
                target_type_raw = None

                # ---------------------------------------------------------------------
                # Attribute Detection
                # ---------------------------------------------------------------------
                
                # Method 1: Check for the dedicated reflection field (newer flatc versions)
                try:
                    if hasattr(field, 'NestedFlatbufferName'):
                        nb = field.NestedFlatbufferName()
                        if nb:
                            target_type_raw = nb.decode("utf-8")
                except (AttributeError, TypeError):
                    pass
                
                # Method 2: Check generic attributes (standard 'nested_flatbuffer'="Type")
                if not target_type_raw:
                    for k in range(field.AttributesLength()):
                        attr = field.Attributes(k)
                        if attr.Key().decode("utf-8") == NESTED_ATTRIBUTE_KEY:
                            target_type_raw = attr.Value().decode("utf-8")
                            break

                # If no attribute found, move to next field
                if not target_type_raw:
                    continue

                # ---------------------------------------------------------------------
                # Validation & Generation
                # ---------------------------------------------------------------------

                if not self.validate_field_compatibility(field, full_table_name):
                    continue

                resolved_type = self.resolve_type_name(target_type_raw, namespace)
                
                if not resolved_type:
                    print(f"ERROR: Could not resolve nested type '{target_type_raw}'")
                    print(f"       referenced in field '{full_table_name}::{field_name}'")
                    print(f"       File: {self.filename}")
                    sys.exit(1)

                # Generate the C++ template specialization
                traits.append(
                    f"template<>\n"
                    f"struct nested_type<&{cpp_table_name}::{field_name}> {{\n"
                    f"    using type = {to_cpp_type(resolved_type)};\n"
                    f"}};"
                )

        return traits


# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description="Generate lazy FlatBuffer traits.")
    parser.add_argument("schema_bfbs", help="Path to the binary schema (.bfbs) file.")
    parser.add_argument("output_hpp", help="Path to the output C++ header file.")
    parser.add_argument("include_header", help="The C++ generated header to include (e.g., monster_generated.h).")
    args = parser.parse_args()

    # 1. Validation: Ensure input file exists
    if not os.path.exists(args.schema_bfbs):
        print(f"ERROR: Input schema file not found: {args.schema_bfbs}")
        sys.exit(1)

    # 2. Loading: Read the binary schema
    try:
        with open(args.schema_bfbs, "rb") as f:
            buf = f.read()
    except IOError as e:
        print(f"ERROR: Failed to read input file '{args.schema_bfbs}': {e}")
        sys.exit(1)

    # 3. Analysis: Parse schema and extract traits
    try:
        analyzer = SchemaAnalyzer(buf, args.schema_bfbs)
        traits_list = analyzer.extract_traits()
    except Exception as e:
        print(f"ERROR: Failed during schema analysis: {e}")
        # Print stack trace for debugging if needed
        import traceback
        traceback.print_exc()
        sys.exit(1)

    # 4. Generation: Write the output header
    try:
        # Ensure output directory exists
        output_dir = os.path.dirname(args.output_hpp)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)

        with open(args.output_hpp, "w") as f:
            f.write("// AUTO-GENERATED FILE - DO NOT EDIT\n")
            f.write(f"// Generated from: {os.path.basename(args.schema_bfbs)}\n\n")
            f.write("#pragma once\n\n")
            
            # Include the user's generated flatbuffer header (e.g., "monster_generated.h")
            f.write(f'#include "{args.include_header}"\n')
            
            # Include the core Lazy library
            f.write(f'#include <{LAZY_WRAPPER_HEADER}>\n\n')
            
            f.write(f"namespace {TRAITS_NAMESPACE} {{\n\n")
            
            if traits_list:
                f.write("\n".join(traits_list))
            else:
                f.write(f"// No fields with '{NESTED_ATTRIBUTE_KEY}' found in this schema.\n")
                
            f.write(f"\n\n}} // namespace {TRAITS_NAMESPACE}\n")
            
    except IOError as e:
        print(f"ERROR: Failed to write output file '{args.output_hpp}': {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
