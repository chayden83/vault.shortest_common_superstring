#!/usr/bin/env python3
"""
Generates C++ traits for lazy FlatBuffer wrappers.
Filters types by their declaration file to prevent redefinition errors and 
uses strict namespace resolution to prevent collisions.
"""

import sys
import os
import argparse
from typing import List, Dict, Optional

# Core FlatBuffers runtime
try:
    import flatbuffers
except ImportError:
    print("Error: The 'flatbuffers' python package is missing.")
    sys.exit(1)

# Reflection modules generated by CMake
try:
    import reflection.Schema
    import reflection.Object
    import reflection.Field
    import reflection.BaseType
except ImportError:
    print(f"Error: Could not import 'reflection' modules. Check PYTHONPATH.")
    sys.exit(1)

def get_namespace(obj_name: str) -> str:
    return ".".join(obj_name.split(".")[:-1]) if "." in obj_name else ""

def to_cpp_type(flatbuffer_name: str) -> str:
    return flatbuffer_name.replace(".", "::")

class SchemaParser:
    def __init__(self, buffer: bytes):
        self.schema = reflection.Schema.Schema.GetRootAsSchema(buffer, 0)
        self.objects_by_name: Dict[str, reflection.Object.Object] = {}
        self._index_objects()

    def _index_objects(self):
        for i in range(self.schema.ObjectsLength()):
            obj = self.schema.Objects(i)
            name = obj.Name().decode("utf-8")
            self.objects_by_name[name] = obj

    def find_object(self, name: str, context_namespace: str = "") -> Optional[str]:
        """
        Strict namespace resolution hierarchy:
        1. Absolute match (exact full name).
        2. Relative match (relative to the context namespace).
        3. Global search (only if unique).
        """
        # 1. Absolute match
        if name in self.objects_by_name:
            return name
        
        # 2. Relative match
        if context_namespace:
            relative_name = f"{context_namespace}.{name}"
            if relative_name in self.objects_by_name:
                return relative_name
        
        # 3. Global search with ambiguity check
        matches = [k for k in self.objects_by_name.keys() if k.split('.')[-1] == name]
        if len(matches) == 1:
            return matches[0]
        elif len(matches) > 1:
            print(f"Error: Ambiguous type '{name}' found in multiple namespaces: {matches}")
            print(f"Please use the fully qualified name in your .fbs attribute.")
            sys.exit(1)
            
        return None

    def validate_field_type(self, field: reflection.Field.Field, table_name: str) -> bool:
        type_obj = field.Type()
        is_vector = type_obj.BaseType() == reflection.BaseType.BaseType.Vector
        is_byte = type_obj.Element() in (reflection.BaseType.BaseType.UByte, reflection.BaseType.BaseType.Byte)
        
        if not (is_vector and is_byte):
            field_name = field.Name().decode("utf-8")
            print(f"Warning: Field '{table_name}::{field_name}' skipped. "
                  f"'nested_flatbuffer' requires a byte vector [ubyte].")
            return False
        return True

    def generate_cpp_traits(self, current_bfbs_name: str) -> List[str]:
        traits = []
        base_filter_name = os.path.basename(current_bfbs_name).replace(".bfbs", ".fbs")

        for i in range(self.schema.ObjectsLength()):
            obj = self.schema.Objects(i)
            if obj.IsStruct():
                continue

            # Ownership check to prevent redefinitions across transitive includes
            if hasattr(obj, 'DeclarationFile') and obj.DeclarationFile():
                decl_file = obj.DeclarationFile().decode("utf-8")
                if os.path.basename(decl_file) != base_filter_name:
                    continue

            full_table_name = obj.Name().decode("utf-8")
            cpp_table_name = to_cpp_type(full_table_name)
            namespace = get_namespace(full_table_name)

            for j in range(obj.FieldsLength()):
                field = obj.Fields(j)
                field_name = field.Name().decode("utf-8")
                nested_type_raw = None

                try:
                    if hasattr(field, 'NestedFlatbufferName'):
                        nb = field.NestedFlatbufferName()
                        if nb:
                            nested_type_raw = nb.decode("utf-8")
                except (AttributeError, TypeError):
                    pass
                
                if not nested_type_raw:
                    for k in range(field.AttributesLength()):
                        attr = field.Attributes(k)
                        if attr.Key().decode("utf-8") == "nested_flatbuffer":
                            nested_type_raw = attr.Value().decode("utf-8")
                            break

                if nested_type_raw:
                    if not self.validate_field_type(field, full_table_name):
                        continue

                    resolved = self.find_object(nested_type_raw, namespace)
                    if not resolved:
                        print(f"Error: Could not resolve nested type '{nested_type_raw}' in '{full_table_name}'")
                        sys.exit(1)

                    traits.append(
                        f"template<>\n"
                        f"struct nested_type<&{cpp_table_name}::{field_name}> {{\n"
                        f"    using type = {to_cpp_type(resolved)};\n"
                        f"}};"
                    )
        return traits

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("schema_bfbs")
    parser.add_argument("output_hpp")
    parser.add_argument("include_header")
    args = parser.parse_args()

    with open(args.schema_bfbs, "rb") as f:
        parser_obj = SchemaParser(f.read())

    traits = parser_obj.generate_cpp_traits(args.schema_bfbs)

    with open(args.output_hpp, "w") as f:
        f.write("// AUTO-GENERATED - DO NOT EDIT\n#pragma once\n\n")
        f.write(f'#include "{args.include_header}"\n')
        f.write('#include <vault/flatbuffers/flatbuffers.hpp>\n\n')
        f.write("namespace lazyfb::traits {\n\n")
        f.write("\n".join(traits) if traits else "// No local nested fields found.")
        f.write("\n\n} // namespace lazyfb::traits\n")

if __name__ == "__main__":
    main()
